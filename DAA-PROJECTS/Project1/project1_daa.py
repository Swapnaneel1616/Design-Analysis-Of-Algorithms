# -*- coding: utf-8 -*-
"""Project1_DAA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YRo-HQPtbh5_bG1BeGB8y2nNTM6xOsR0

PROJECT 1 - G20936219
"""

'''
j = 2
while (j < n) {
    k = j
    while (k < n) {
        Sum += a[k] * b[k]
        k = k * k
    }
    j += log k
}
'''

import time
import math
import matplotlib.pyplot as plt

#Defining the algorithm given in the problem

def algorithm(n):
    j = 2
    Sum = 0
    a = [i for i in range(n)]
    b = [i for i in range(n)]

    while j < n:
        k = j
        while k < n:
            Sum += a[k] * b[k]
            k = k * k
        j += int(math.log(k))
    return Sum

#TAKING UP SOME INPUT VALUES FOR THE EXPERIMENT
ns = [100, 500, 1000, 2000, 5000, 10000]

#Measuring out the experimental runtime for this(non normalised)

times = []
for n in ns:
    start = time.time()
    algorithm(n)
    end = time.time()
    times.append(end - start)
theoretical = [(n * math.log(math.log(n)) / math.log(n)) for n in ns]

#Plot 1 without normalising
plt.figure(figsize=(8,5))
plt.plot(ns, times, marker='o', label="Experimental Runtime")
plt.plot(ns, theoretical, marker='x', label="Theoretical Growth")
plt.xlabel("Input size n")
plt.ylabel("Runtime / Growth")
plt.title("Problem 9: Experimental vs Theoretical Runtime (Unnormalized)")
plt.legend()
plt.grid(True)
plt.show()

#As we can see the experimental curve is coming flat so we do need to normalise it in the range [0->1]

#Normalising process function
def normalize(values):
    max_val = max(values)
    return [v / max_val for v in values]

times_norm = normalize(times)
theoretical_norm = normalize(theoretical)

#Plot after normalising
plt.figure(figsize=(8,5))
plt.plot(ns, times_norm, marker='o', label="Experimental (Normalized)")
plt.plot(ns, theoretical_norm, marker='x', label="Theoretical (Normalized)")
plt.xlabel("Input size n")
plt.ylabel("Normalized Runtime / Growth")
plt.title("Problem 9: Experimental vs Theoretical Runtime (Normalized)")
plt.legend()
plt.grid(True)
plt.show()

